<!DOCTYPE html>
<html>

<head>
    <mate charset='utf-8'>
        <title>Doc</title>
        <link rel='stylesheet' href='https://lib.baomitu.com/twitter-bootstrap/3.4.1/css/bootstrap.css' />
        <style>
            #line {
                position: absolute;
                left: 4vw;
                width: 92vw;
                height: 8vh;
                background-image: linear-gradient(to right, #333399, #ff00cc);
                border-radius: 25px;
                text-align: center;
                font-size: 5em;
                line-height: 8vh;
                color: blanchedalmond;
                z-index: 999;
            }

            #mapbox {
                width: 100%;
                height: 90vh;
                margin: 0px;
                padding: 0px;
                z-index: 2;
            }

            .result {
                position: absolute;
                top: 90vh;
                width: 60vw;
                height: 10vh;
                background-image: linear-gradient(to right, rgba(12, 153, 94, 0), rgba(12, 153, 94, 1));
                text-align: center;
                line-height: 5vh;
                font-size: 2em;
            }

            .clickbox {
                position: absolute;
                top: 90vh;
                left: 60vw;
                width: 40vw;
                height: 10vh;
                background-color: rgb(12, 153, 94);
                text-align: center;
            }
        </style>
        <script type="text/javascript"
            src="https://api.map.baidu.com/api?v=1.0&type=webgl&ak=LZkegj6Z5zFKV2iRLGcDCGdyIaUKkGlN"></script>
</head>

<body>
    <div id="line">
        地形图分幅计算
    </div>
    <div id="mapbox">
    </div>
    <div class="result">
        <input type="text" id="longtitude" style="width: 45vw;height: 3.5vh;" placeholder="经度,若都不填写则由GPS定位">
        <br>
        <input type="text" id="latitude" style="width: 45vw;height: 3.5vh;" placeholder="纬度,定位后再次计算即可">
    </div>
    <div class="clickbox">
        <br>
        <button style="height: 3vh;width: 20vw;font-size: 1.2em;" onclick="clicking()">计算图幅(定位)</button>
        <br>
        <h4>比例尺选择：</h4>
        <br>
        <select id="selected" style="width: 25vw;height: 2vh;">
            <option value="7">1:5000</option>
            <option value="6">1:1万</option>
            <option value="5">1:2.5万</option>
            <option value="4">1:5万</option>
            <option value="3">1:10万</option>
            <option value="2">1:25万</option>
            <option value="1">1:50万</option>
            <option value="0">1:100万</option>
        </select>
    </div>
    <script src='https://lib.baomitu.com/jquery/3.6.0/jquery.js'></script>
    <script src='https://lib.baomitu.com/twitter-bootstrap/3.4.1/js/bootstrap.js'></script>
    <script>
        var map = new BMapGL.Map("mapbox");          // 创建地图实例 
        //var point = new BMapGL.Point(116.404, 39.915);  // 创建点坐标 
        map.centerAndZoom("西安市", 10);                 // 初始化地图，设置中心点坐标和地图级别
        map.enableScrollWheelZoom(true);
        var map = new BMapGL.Map("allmap", {
            enableRotate: false,
            enableTilt: false
        });
        //地图分幅结果
        //0代表1比100万
        //以此类推标准比例尺
        //7代表1：5000
        //参数分别为经度、纬度、比例尺级别
        function check_code(a, b, c) {
            //纬度代码
            var code = "ABCDEFGHIJKLMNOPQRSTUVWX";
            var map_code;
            //经度参数
            var lo_code = Math.floor((a + 180) / 6) + 1;
            //纬度参数
            var la_code = Math.floor(b / 4);
            //地图分幅起算点
            var lo = -(lo_code * 6) + a + 186;
            var la = b - (la_code * 4) - 4;

            if (c == 0) {
                map_code = code[la_code] + lo_code.toString();
                return map_code;
            }

            if (c == 1) {
                map_code = code[la_code] + lo_code.toString() + "B," + Math.ceil(la / -2).toString() + "," + Math.ceil(lo / 3).toString();
                return map_code;
            }
            if (c == 2) {
                map_code = code[la_code] + lo_code.toString() + "C, " + Math.ceil(la / -1).toString() + " ," + Math.ceil(lo / 1.5).toString();
                return map_code;
            }
            if (c == 3) {
                map_code = code[la_code] + lo_code.toString() + "D, " + Math.ceil(la / -(1 / 3)).toString() + " ," + Math.ceil(lo / 0.5).toString();
                return map_code;
            }
            if (c == 4) {
                map_code = code[la_code] + lo_code.toString() + "E, " + Math.ceil(la / -(1 / 6)).toString() + " ," + Math.ceil(lo / 0.25).toString();
                return map_code;
            }
            if (c == 5) {
                map_code = code[la_code] + lo_code.toString() + "F, " + Math.ceil(la / -(1 / 12)).toString() + " ," + Math.ceil(lo / (75 / 600)).toString();
                return map_code;
            }
            if (c == 6) {
                map_code = code[la_code] + lo_code.toString() + "G, " + Math.ceil(la / -(25 / 600)).toString() + " ," + Math.ceil(lo / (345 / 6000)).toString();
                return map_code;
            }
            if (c == 7) {
                map_code = code[la_code] + lo_code.toString() + "H, " + Math.ceil(la / -(75 / 3600)).toString() + " ," + Math.ceil(lo / (225 / 7200)).toString();
                return map_code;
            }
        }

        function group(num, lo, la) {
            var RU = [];
            var LU = [];
            var LD = [];
            var poilgon = [];
            RU.push(num[0]);
            RU.push(num[1] + la);
            LU.push(num[0] - lo);
            LU.push(num[1] + la);
            LD.push(num[0] - lo);
            LD.push(num[1]);
            poilgon.push(LU);
            poilgon.push(RU);
            poilgon.push(num);
            poilgon.push(LD);
            return poilgon;
        }
        //标准分幅四至【左上、右上、左下、右下】
        //参数分别为经度、纬度、比例尺级别
        function poilgon_four(a, b, c) {
            var re;
            var RD = [];
            var lo_code = Math.floor((a + 180) / 6) + 1;
            var la_code = Math.floor(b / 4);
            var lo_s = (lo_code * 6) - 186;
            var la_s = (la_code * 4) + 4;
            var lo = -(lo_code * 6) + a + 186;
            var la = b - (la_code * 4) - 4;
            if (c == 0) {
                RD.push(lo_s + 6);
                RD.push(la_s - 4);
                re = group(RD, 6, 4);
                return re;
            }
            if (c == 1) {
                var lo_num = 3;
                var la_num = 2;
                RD.push(lo_s + Math.ceil(lo / lo_num) * lo_num);
                RD.push(la_s - Math.ceil(la / -la_num) * la_num);
                re = group(RD, lo_num, la_num);
                return re;
            }
            if (c == 2) {
                var lo_num = 1.5;
                var la_num = 1;
                RD.push(lo_s + Math.ceil(lo / lo_num) * lo_num);
                RD.push(la_s - Math.ceil(la / -la_num) * la_num);
                re = group(RD, lo_num, la_num);
                return re;
            }
            if (c == 3) {
                var lo_num = 0.5;
                var la_num = 1 / 3;
                RD.push(lo_s + Math.ceil(lo / lo_num) * lo_num);
                RD.push(la_s - Math.ceil(la / -la_num) * la_num);
                re = group(RD, lo_num, la_num);
                return re;
            }
            if (c == 4) {
                var lo_num = 0.25;
                var la_num = 1 / 6;
                RD.push(lo_s + Math.ceil(lo / lo_num) * lo_num);
                RD.push(la_s - Math.ceil(la / -la_num) * la_num);
                re = group(RD, lo_num, la_num);
                return re;
            }
            if (c == 5) {
                var lo_num = 75 / 600;
                var la_num = 1 / 12;
                RD.push(lo_s + Math.ceil(lo / lo_num) * lo_num);
                RD.push(la_s - Math.ceil(la / -la_num) * la_num);
                re = group(RD, lo_num, la_num);
                return re;
            }
            if (c == 6) {
                var lo_num = 345 / 6000;
                var la_num = 25 / 600;
                RD.push(lo_s + Math.ceil(lo / lo_num) * lo_num);
                RD.push(la_s - Math.ceil(la / -la_num) * la_num);
                re = group(RD, lo_num, la_num);
                return re;
            }
            if (c == 7) {
                var lo_num = 225 / 7200;
                var la_num = 75 / 3600;
                RD.push(lo_s + Math.ceil(lo / lo_num) * lo_num);
                RD.push(la_s - Math.ceil(la / -la_num) * la_num);
                re = group(RD, lo_num, la_num);
                return re;
            }
        }

        function map_ratio_check() {
            selected = document.getElementById("selected");
            var num = selected.value;
            return num
        }

        function clicking() {
            var longtitude = Number(document.getElementById('longtitude').value);
            var latitude = Number(document.getElementById('latitude').value);
            var c = map_ratio_check();

            if (longtitude != 0 & latitude != 0) {
                alert("计算成功");
                var line = document.getElementById('line');
                var points = [new BMapGL.Point(longtitude, latitude)];
                var map_code = check_code(longtitude, latitude, c);
                line.innerHTML = map_code;
                var orpoi = poilgon_four(longtitude, latitude, c);
                for (var i = 0; i < orpoi.length; i++) {
                    points.push(new BMapGL.Point(orpoi[i][0], orpoi[i][1]));
                }
                //坐标转换完之后的回调函数
                tr = function (data) {
                    if (data.status === 0) {
                        var marker = new BMapGL.Marker(data.points[0]);        // 创建标注   
                        map.addOverlay(marker);                     // 将标注添加到地图中
                        map.centerAndZoom(data.points[0], 15);
                        var polipoi = [];
                        for (var i = 1; i < data.points.length; i++) {
                            polipoi.push(data.points[i])
                        }
                        var polygon = new BMapGL.Polygon(polipoi, { strokeColor: "blue", strokeWeight: 2, strokeOpacity: 0.5 });
                        map.addOverlay(polygon);
                    }
                }
                setTimeout(function () {
                    var convertor = new BMapGL.Convertor();
                    convertor.translate(points, COORDINATES_WGS84, COORDINATES_BD09, tr)
                }, 1000);
            }
            else {
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(showPosition);
                }
                else {
                    alert("定位权限错误");
                }
                function showPosition(position) {
                    alert('定位成功');
                    longtitude = position.coords.longitude;
                    latitude = position.coords.latitude;
                    document.getElementById('longtitude').value = longtitude;
                    document.getElementById('latitude').value = latitude;
                }
            }
        }
    </script>
</body>

</html>